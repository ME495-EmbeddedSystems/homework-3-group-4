from moveit_msgs.msg import CollisionObject, AttachedCollisionObject
from shape_msgs.msg import SolidPrimitive
from geometry_msgs.msg import PoseStamped,Pose
from moveit.planning import MoveItPy
from rclpy.logging import get_logger
import rclpy

#Add or remove boxes to the planning scene dynamically, at any location
class PlanningScene:
    
    def __init__(self):
        rclpy.init()
        # instantiate MoveItPy instance and get planning component
        self.panda = MoveItPy(node_name="moveit_py_planning_scene")
        self.panda_arm = self.panda.get_planning_component("panda_arm")
        self.planning_scene_monitor = self.panda.get_planning_scene_monitor()
        self.get_logger.info("MoveItPy instance created")

        self.objects = {}  # Dictionary to store objects with their properties (location, size)
        self.attach_object = {}


    # Method to add a box to the scene at a specified location and size
    def add_collision_objects(self, name, position, dimension):
        # position and dimensions are tuples like (x, y, z) and (width, height, depth)
        with self.planning_scene_monitor.read_write() as scene:
            collision_object = CollisionObject()
            collision_object.header.frame_id = f"panda_link_{name}"
            collision_object.id = name

            self.objects[name] = collision_object

            box_pose = Pose()
            box_pose.position.x = position[0]
            box_pose.position.y = position[1]
            box_pose.position.z = position[2]

            box = SolidPrimitive()
            box.type = SolidPrimitive.BOX
            box.dimensions = dimension

            collision_object.primitives.append(box)
            collision_object.primitive_poses.append(box_pose)
            collision_object.operation = CollisionObject.ADD

            scene.apply_collision_object(collision_object)
            scene.current_state.update()  # Important to ensure the scene is updated

    def remove_box(self, name):
        collision_object = self.objects[name]
        with self.planning_scene_monitor.read_write() as scene:
            collision_object.operation = CollisionObject.REMOVE
            scene.current_state.update()

    #Method to attach a collision object to the robot's end-effector
    #Attaching an object requires two operations

    # 1.Removing the original object from the environment   

    # 2.Attaching the object to the robot

    def attach_object(self, name):
        if name in self.objects:
            collision_object = self.objects[name]
            self.attach_object[name] = self.objects[name]
            del self.objects[name]
            self.remove_box(name)
        attach_object = AttachedCollisionObject()
        attach_object.id = collision_object.id
        attach_object.header.frame_id= collision_object.header.frame_id


        self.planning_scene.world.collision_objects.clear()
        self.planning_scene.world.collision_objects.push_back(remove_object)
        self.planning_scene.robot_state.attached_collision_objects.push_back(attached_object);   
        self.planning_scene.robot_state.is_diff = true
        self.planning_scene_diff_publisher->publish(planning_scene)
        visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to continue the demo")


    #Method to detach an object from the robot's end-effector
    #Detaching an object from the robot requires two operations

    # 1. Detaching the object from the robot

    # 2. Re-introducing the object into the environment


    def detach_object(self, name):
        if name in self.attached_objects:
            self.objects[name] = self.detach_object[name]
            del self.attached_objects[name]

